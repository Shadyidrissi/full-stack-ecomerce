import isErrorInstance from"is-error-instance";





export const omitStack=(error,stack)=>{
if(!stack){
recurseObject(error,omitStackProp)
}
};

const omitStackProp=(object)=>{
if(
!isErrorInstance(object)||
typeof object.stack!=="string"||
object.stack==="")
{
return
}

setNonEnumProp(object,STACK_SYM,object.stack);

delete object.stack
};

export const restoreStack=(error,stack)=>{
if(!stack){
recurseObject(error,restoreStackProp)
}
};

const restoreStackProp=(object)=>{
if(object[STACK_SYM]===undefined){
return
}

setNonEnumProp(object,"stack",object[STACK_SYM]);

delete object[STACK_SYM]
};

const STACK_SYM=Symbol("stack");

const setNonEnumProp=(object,propName,value)=>{

Object.defineProperty(object,propName,{
value,
enumerable:false,
writable:true,
configurable:true
})
};


const recurseObject=(value,callFunc)=>{
recurseValue(value,callFunc,0)
};

const recurseValue=(value,callFunc,depth)=>{
if(
typeof value!=="object"||
value===null||
depth>=PRINT_MAX_DEPTH+2)
{
return
}

callFunc(value);

Reflect.ownKeys(value).forEach((key)=>{
recurseValue(value[key],callFunc,depth+1)
})
};



export const PRINT_MAX_DEPTH=2;







export const omitStackBracket=(errorString)=>
errorString.replace(STACK_BRACKET_REGEXP,"$1");

const STACK_BRACKET_REGEXP=/^\[([^\]]+)\]/u;
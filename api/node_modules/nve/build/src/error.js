import{stdout,stderr}from"node:process";
import{setTimeout}from"node:timers/promises";

import chalk from"chalk";

import{printInvalidCommand}from"./fault.js";
import{printVersionHeader}from"./header.js";
import{writeProcessOutput}from"./output.js";















export const handleSingleError=({
originalMessage,
code,
exitCode=DEFAULT_EXIT_CODE
})=>{
if(originalMessage!==undefined){
stderr.write(`${originalMessage}\n`)
}

printInvalidCommand(code,exitCode);

return exitCode
};


export const handleSerialError=(error,version,state)=>{
handleMultipleError(error,version,state)
};




export const handleParallelError=async({
error,
version,
continueOpt,
state,
index
})=>{
if(continueOpt){
handleAnyParallelError({error,version,state,index});
return
}


await setTimeout(0);

handleFastParallelError({error,version,state,index})
};


const handleFastParallelError=({error,version,state,index})=>{
printAborted({error,version,state,index});
handleAnyParallelError({
error:state.failedError,
version:state.failedVersion,
state,
index:state.failedIndex
})
};




const printAborted=({
error,
version,
state:{failedError,failedVersion},
index
})=>{
if(failedError===error){
return
}

writeProcessOutput(error.all,stdout,index);

stderr.write(chalk.red(`Node ${version} aborted\n`));

printVersionHeader(failedVersion)
};


const handleAnyParallelError=({error,version,state,index})=>{
writeProcessOutput(`${error.all}\n`,stdout,index);
handleMultipleError(error,version,state)
};








const handleMultipleError=(
{shortMessage,code,exitCode=DEFAULT_EXIT_CODE},
version,
state)=>
{
const commandMessage=getCommandMessage(shortMessage,version);
stderr.write(`${commandMessage}\n`);

printInvalidCommand(code,exitCode);

state.exitCode=exitCode
};

const getCommandMessage=(shortMessage,version)=>
chalk.red(
shortMessage.
replace(COMMAND_REGEXP,"").
replace("Command",`Node ${version}`)
);


const COMMAND_REGEXP=/:.*/u;

const DEFAULT_EXIT_CODE=1;

import{stdout}from"node:process";

import{execa}from"execa";
import nvexeca from"nvexeca";

import{cancelOnError}from"./abort.js";
import{cleanupProcesses}from"./cleanup.js";
import{getColorOptions}from"./colors.js";
import{printVersions}from"./dry.js";
import{handleParallelError}from"./error.js";
import{printVersionHeader}from"./header.js";
import{writeProcessOutput}from"./output.js";

import{getParallelStdinOptions}from"./stdin.js";


export const runParallel=async({
versionRanges,
command,
args,
continueOpt,
opts,
controller
})=>{
if(command===undefined){
return printVersions(versionRanges,opts,controller)
}

const stdinOptions=await getParallelStdinOptions();
const colorOptions=getColorOptions();
const optsA={
...opts,
dry:true,
...stdinOptions,
...colorOptions,
stdout:"pipe",
stderr:"pipe",
buffer:true,
all:true,
stripFinalNewline:true,
reject:true
};

const versions=await startProcesses({
versionRanges,
command,
args,
opts:optsA,
controller
});

const state={};
await Promise.all([
cleanupProcesses(versions,continueOpt,state),
runProcesses(versions,continueOpt,state)]
);

return state.exitCode
};




const startProcesses=async({
versionRanges,
command,
args,
opts,
controller
})=>{
const versions=await cancelOnError(
versionRanges.map((versionRange)=>
nvexeca(versionRange,command,args,opts)
),
controller
);
const versionsA=versions.map(startProcess);
return versionsA
};

const startProcess=({version,command,args,execaOptions})=>{
const childProcess=execa(command,args,execaOptions);
return{childProcess,version}
};



const runProcesses=async(versions,continueOpt,state)=>{

let index=0;


for(const{childProcess,version}of versions){

const shouldStop=await runProcess({
childProcess,
version,
continueOpt,
state,
index
});





if(shouldStop){
return
}


index+=1
}
};

const runProcess=async({
childProcess,
version,
continueOpt,
state,
index
})=>{
printVersionHeader(version);




if(index===0){
childProcess.all.pipe(stdout)
}

try{
const{all}=await childProcess;
writeProcessOutput(all,stdout,index)
}catch(error){
await handleParallelError({error,version,continueOpt,state,index});
return!continueOpt
}
};